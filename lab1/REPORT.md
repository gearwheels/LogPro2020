# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Тимофеев А.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

В Прологе список — это объект, который содержит конечное число других объектов. Список можно представить как бинарное дерево и дать следующее рекурсивное определение: пустой список является списком, список состоит из элемента (головы) и другого списка (хвоста). Такое представление показывает каким образом чаще всего происходит работа со списками, обрабатывается голова и рекурсивно вызывается та же функция для хвоста, пока он не будет пустым.

Списки можно сравнить с динамическими массивами в императивных языках, но, подход к хранению данных в списке Пролога отличаются, в первую очередь, произвольным типом элементов, такое отношение к типам редко встречается в императивных языках.

## Задание 1.1: Предикат обработки списка

`removeLN(L,Y,N)` - Удаление N последних элементов с использованием стандартный предикатов.

`removelast(S,N,L)` - Удаление N последних элементов без стандартных предикатов.

Примеры использования:
```prolog
?- removeLN([a,aa,ref,d,s,a,w],R,3).
R = [a, aa, ref, d].

?- removelast([a,aa,ref,d,s,a,w],3,R).
R = [a, aa, ref, d] .

?- removelast([a,aa,r,u,f,qdf,f,e,f],5,R).
R = [a, aa, r, u] .
```

Реализация:
```prolog
% Со стандартными 
% (Список входной, список выходной, длина которую нужно отсечь)
removeLN(L,Y,N):-append(Y,X,L), length(X, N).
% без встроенных предикатов
get_first_elements(_,N,[]):-N=<0.
get_first_elements(X,0,[]).
get_first_elements([X|Xt],N,[X|Yt]):-N>0,N1 is N-1 get_first_elements(Xt,N1,Yt).
%(Список, количество элементов к удалению, список-результат)
removelast([],_,[]).
removelast(S,N,L) :- myLength(S,D),N1 is D-N, get_first_elements(S,N1,L).
```

Предикат с использованием стандартных предикатов:<br>
С помощью append'а рассматриваем все возможности разбиения списка, а с помощью length находим разбиение нужной длины и отсекаем его, выводим оставшейся список. 

Предикат без стандартных предикатов:<br>
Находим длину списка который нужно вывести, поэлементно находим список нужной длины и выводим его.

## Задание 1.2: Предикат обработки числового списка

`lcom(X,Y)` - Лексикографическое сравнение 2 списков с использованием стандартных предикатов.

`lcomp1(X,Y)` - Лексикографическое сравнение 2 списков без стандартных предикатов.

Примеры использования:
```prolog
?- lcom([1,2,3,50], [5,2,3,50]).
false.

?- lcom([1,2,3,50], [1,2,3,50]).
true.
?- lcomp1([1,2,3,50], [1,2,3,50]).
true .

?- lcomp1([1,2,3,50], [1,2,3]).
false.

?- lcomp1([1,2,3,50], [1,2,4,50]).
false.

?- lcomp1([1,2,3,50], [5,2,3,50]).
false.
```

Реализация:
```prolog
% с использованием стандартных предикатов
lcom([],[]).
lcom([X|Tail],Y) :- delete(Y,X,Y1), lcom(Tail,Y1).
% без встроенных предикатов 
lcomp1([X|Tail],[Y|Tail1]) :- X =:= Y, lcomp1(Tail, Tail1).
lcomp1([X],[Y]) :- X =:= Y.
```

## Задание 1.3: Пример совместного использования

`headcomp1(X,Y,N)` Предикат, который отсекает заданное количество последних элементов списка и производит лексикографическое сравнение оставшихся.

Примеры использования:

```

?- headcomp1([1,2,3,50], [1,2,3,50],2).
true.

?- headcomp1([1,2,3,50], [1,4,3,50],2).
false.

?- headcomp1([1,2,3,50], [1,2,3,50,50],2).
false.

?- headcomp1([1,2,3,50,20], [1,2,3,50,50],2).
true.
```

Реализация:

```
%(список 1, список 2, кол-во элементов которые нужно отсечь)
headcomp1(S1,S2,K) :- removelast(S1,K,L1), removelast(S2,K,L2), lcomp1(L1,L2).
```

Отсекаем с конца заданное количество знаков и проверяем оставшиеся на совпадение. 

## Задание 2: Реляционное представление данных

Термин «реляционный» означает, что теория основана на понятии отношениях (relation) между объектами, а задачей программиста является анализ этих отношений. Вся задача сводится к реализации такого алгоритма, который обеспечит выдачу полных ответов без повторений (или с ними если это требуется). Преимуществом является то, что программа разбивается на отдельные компоненты, которые реализуются независимо друг от друга. Это позволяет тестировать программу в ходе разработки просто подставляя нужные данные в определенные блоки.

Представление моего варианта базы данных является набором фактов.
Плюсы такого представления: 

* легко получить данные второго объекта если известен первый и их связывает отношение.

* легко составлять простые списки.

минусы:

* если объект 1 и объект 2 не связанны отношением напрямую то получить данные о них становится сложнее.

Данные : one.pl

Вариант 1 <br>
Получить таблицу групп и средний балл по каждой из групп. <br>
Для каждого предмета получить список студентов, не сдавших экзамен (grade=2). <br>
Найти количество не сдавших студентов в каждой из групп. <br>

Получить таблицу групп и средний балл по каждой из групп. <br>
Предикат `avAllMarksG(Group,Marks)` создает список групп, по каждой группе находит средний бал и записывает его в список.
Так как в Прологе формализовать выводы крайне сложно, я решил вывести список групп и среднюю оценку под номером каждой группы, из-за размера оценок получилось неровно, но ничего лучше придумать у меня не получилось. В листинге я указал что делают вспомогательные предикаты.

Для каждого предмета получить список студентов, не сдавших экзамен (grade=2). <br>
Предикат `listDNP(Subj, Names)` составляет список всех не сдавших заданный предмет.

Найти количество не сдавших студентов в каждой из групп. <br>
Предикат `dvoechnikiout(GR,KLV)` находим всех студентов в нужной группе, находим всех двоечников, пересекаем эти два списка получаем третий список, находим его длину и выводит ее.

Примеры использования:
```prolog
?- avAllMarksG(Group,Marks).
Group = [101, 104, 103, 102],
Marks = [3.9, 3.861111111111111, 3.7708333333333335, 3.770833333333333] .

?- listDNP('Математический анализ',Names).
Names = ['Запорожцев', 'Круглосчиталкин', 'Густобуквенникова', 'Криптовалютников', 'Блокчейнис', 'Азурин'].

?- listDNP('Функциональное программирование',Names).
Names = ['Криптовалютников'].

?- listDNP('Информатика',Names).
Names = ['Эфиркина', 'Джаво', 'Безумников'].

?- listDNP('Английский язык',Names).
Names = ['Эфиркина'].

?- listDNP('Психология',Names).
Names = ['Биткоинов', 'Текстописова', 'Криптовалютников', 'Азурин', 'Вебсервисов'].

?- dvoechnikiout(101,N).
N = 2.

?- dvoechnikiout(102,N).
N = 4.

?- dvoechnikiout(103,N).
N = 3.

?- dvoechnikiout(104,N).
N = 4.

``````

Листинг:
```prolog
:- ['one.pl'].
:- encoding(utf8)

writeList([]).
writeList([X|Tail]) :- write(X), writeList(Tail).

add(E,[],[E]).
add(E,[H|T],[H|T1]):-add(E,T,T1).
%Вариант 1
%Получить таблицу групп и средний балл по каждой из групп
% (список, сумма) предикат суммирует элементы списка.
sumlist([H|T],Sum):-sumlist(T,Sum1), Sum is H + Sum1.
sumlist([],0).
%(Имя, Средняя оценка студента) находим ср. оценку студента
spM1std(Name,AvMark) :- findall(Y, (grade(Name, _, Y)), Marks), length(Marks,N), sumlist(Marks,S), AvMark is S / N.
% (список учащихся в группе, промежуточный список ср. оценок, список ср. оценок каждого студента) составляем список средних оценок для учеников.
applist([],[],[]). 
applist([N1|Tail],Out, Out2) :- spM1std(N1,AVM), add(AVM,Out,Out1), applist(Tail,Out1,Out2).
applist([N1],Out, Out2) :- spM1std(N1,AVM), add(AVM,Out,Out2).
%(группа, ср. оценка по группе) входная инф-ия - группа, ищем всех учащихся в группе, получаем список из средних оценок учащихся, получаем сумму этого списка и делим ее на длину списка.
avMGroup(Group, AV) :- findall(Name,(student(Group,Name)),Names), applist(Names, [], AvMarks), length(AvMarks,N),
 sumlist(AvMarks, Sum), AV is Sum / N.
% (список неповторяющихся групп, список ср. оценок по группам) вносим в список среднюю оценку по группе.
func1([Gr|T],L, SpAvMark) :- avMGroup(Gr,A), add(A,L, SpAvMark1), func1(T,SpAvMark1,SpAvMark).
func1([Gr],L, SpAvMark) :- avMGroup(Gr,A), add(A,L, SpAvMark).
%(список групп, список групп без повторений) из списка с повторяющимися группами делаем список групп без повторений.
nonrecGR([H|T],T1):-member(H,T),nonrecGR(T,T1).
nonrecGR([H|T],[H|T1]):-not(member(H,T)),nonrecGR(T,T1).
nonrecGR([],[]).
% получаем список всех групп
allGroup(Groups) :- findall(G, student(G,_), Groups).
%(список групп, список средних баллов) главный предикат
avAllMarksG(OGroups,Spmarks) :- allGroup(Groups), nonrecGR(Groups, OGroups), func1(OGroups,[], Spmarks).

%Для каждого предмета получить список студентов, не сдавших экзамен (grade=2)
%(предмет, список не сдавших)
listDNP(Subj, Names) :- subject(Ss,Subj), bagof(Name ,(grade(Name, Ss, 2)), Names).

%Найти количество не сдавших студентов в каждой из групп
%(список1, второй список, пересечение 2-х списков) находим пересечение списков.
result([],_,[]).
result([Head|Tail],List,[Head|NewTail]):- member(Head,List),result(Tail,List,NewTail),!.
result([_|Tail],List,NewTail):-result(Tail,List,NewTail).
%(группа, кол-во двоечников) находим всех студентов в нужной группе, находим всех двоечников, пересекаем эти два списка получаем третий список, находим его длину
dvoechnikiout(GR,KLV) :- findall(Stud, student(GR,Stud), Studs), findall(Name, grade(Name,H,2), Names),result(Studs,Names,Out), length(Out, KLV).
``````

## Выводы

Пролог отличыается от привычных мне императивных языков программирования. Потому что программист описывает задачу, которую Пролог, по сути, решает сам. Писать код для Пролога не самая легкая задача, потому что это процесс заставляет программиста мыслить глобально, логически, не пошагово. <br> Примечательно, что иногда Пролог находит нетривиальное решение задачи, которое программист и не представлял увидеть среди ответов, но в то же время удовлетворяющее условиям задачи. <br>
Пролог является мощным и удобным средством при работе с базами данных и их анализе, но если перед программистом стоит задача, где придется производить много вычислений, лучше не использовать пролог, потому что арифметика это его слабое место. 
