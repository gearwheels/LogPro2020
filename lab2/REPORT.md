#№ Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Тимофеев А.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Решение логических задач имеет 2 основных подхода: метод порождения и проверок и метод ветвей и границ. Главное их свойство в том, что они перебирают набор решений, и проверяют, удовлетворяет ли он заданным условиям. Их различие сводится к методам проверки удовлетворения заданным условиям. Метод проверок можно разделить на две отдельные части: первая часть генератор: она пытается угадать данные (генерирует множество исходных данных), и второй части, проверяющей. Проверяющая часть, соответственно проверяет решение. Второй метод отличается от первого. В методе ветвей и границ проверяющая часть и генератор тесно связаны: генерация всех условий происходит не моментально (сразу все), а постепенно, шагами. Значительные части возможных, но неверных, решений отсекаются на ранних шагах.

Мою задачу можно решить двумя способами, что я и сделал.<br>Первый способ основан на переборе всех возможных решений пока мы не встретим подходящее нам, тогда перебор прекращается. Это решение можно получить задав программе solve(BO,PO,SO,LO).<br> Второй  предполагает запрограммированное вычисление количества баллов у каждого из рыбаков, осуществляется по запросу mainmain(BO,PO,SO,LO).

## Задание

Цель работы: Написать и отладить Пролог-программу решения логической задачи в соответствии с номером варианта, проанализировать эффективность, безопасность и непротиворечивость решения. Под эффективностью и безопасностью понимать сведение к минимуму операций перебора и предотвращение зацикливания и комбинаторного взрыва нелогическими средствами языка Пролог. Под непротиворечивостью понимать поиск единственно верного решения (Примечание: каждая из задач лабораторной работы имеет ровно одно решение).
#### Задача №24.
Сергеев, Панин, Борисов и Леднев решили посоревноваться на звание лучшего рыбака. Но ведь рыба рыбе рознь. Поэтому они решили каждую рыбу оценивать по-разному: поймал судака получай 5 очков, за леща 4, за окуня 2, а за ерша 1 очко. Единственного судака поймал Сергеев. Было выловлено всего 3 окуня. Все рыбаки вместе набрали 18 очков. Меньше всего очков получил Панин, хотя он и наловил больше всех. Панин и Борисов вместе набрали столько же очков, сколько Сергеев и Леднев вместе. И наконец, у всех оказалось разное количество очков. Определите, какой улов был у каждого из рыбаков?

## Принцип решения

Предикат solve(BO,PO,SO,LO). использует 4 цикла for для подбора правильной последовательности баллов каждого из рыбаков. Каждая последовательность проверяется набором фактов, первая соответствующая всем фактам последовательность берется для обработки. Обработка заключается в нахождении списка рыб (из названий рыбы) соответствующего найденному количеству баллов.   

По запросу mainmain(BO,PO,SO,LO). осуществляется второй вид решения, без явного подбора. Используя данные мне в задаче условия, я запрограммировал предикат serchpointsout, который определяет количество очков у каждой пары, а потом у каждого участника. Далее происходит обработка, и в первом и во втором решение она общая. 

#### Листинг.

```prolog
fishers(['Сергеев', 'Панин', 'Борисов', 'Леднев']).
fishes([['Судак',5],['Лещ',4],['Окунь',2],['Ёрш',1]]).
fishes1(['Судак','Лещ','Окунь','Ёрш']).
fact1([B,P,S,L]) :- B + P =:= S + L.
fact3([B,P,S,L]) :- B > P, B > S, B > L, P < S, P < L, S =\= L.
% сумма очков всех рыбаков
fact(List) :- sumlist(List,Sum), Sum =:= 18.

factPoint(Points,P) :- Points > 0 ,!, p(Points,X), slagList(X,P,0).
factPoint(0,P,Out).
slagList([H|Tail],P,O) :- length(H, Len), P>Len, slagList1(H), !, slagList([],P,1).
slagList([H|Tail],P,0) :- slagList(Tail,P,0).
slagList([],P,1). 

slagList1([1|T]) :- slagList1(T).
slagList1([2|T]) :- slagList1(T).
slagList1([4|T]) :- slagList1(T).
slagList1([5|T]) :- slagList1(T).
slagList1([]).

add(E,[],[E]).
add(E,[H|T],[H|T1]):-add(E,T,T1).

number_compositions(0, _PreviousAddend, []):-!.
number_compositions(Number, PreviousAddend, [Addend|TailComprosition]):-
  between(PreviousAddend, Number, Addend),
  TailNumber is Number - Addend,
  number_compositions(TailNumber, Addend, TailComprosition).

writeList([]).
writeList([X|Tail]) :- write(','), write(' '), write(X), writeList(Tail).

sumlist([H|T],Sum):-sumlist(T,Sum1), Sum is H + Sum1.
sumlist([],0).

for(A,A,_).
for(X,A,B) :- A < B, A1 is A+1, for(X,A1,B).
%решение через перебор
solve(BO,PO,SO,LO) :- for(S,5,8), for(P,1,8), for(L,1,8), for(B,1,8), check([B,P,S,L]),!,kolvofishes(P,B,3,OutB,OstOkun),kolvofishes(P,S,OstOkun,OutSer,OstOkun1),
kolvofishes(P,L,OstOkun1,OutL,OstOkun2), listfishesout(OutB, OstOkun2, BO), listfishesout(OutSer, OstOkun2, SO), 
listfishesout(OutL, OstOkun, LO), fishesPanin(P,[],PO).
%проверка фактов
check([B,P,S,L]) :- fact([B,P,S,L]), fact1([B,P,S,L]), fact3([B,P,S,L]), factPoint(B,P), factPoint(S,P), factPoint(L,P).

p(N,L):-setof(R,number_compositions(N,1,R),L).
% конечный список где позиции числа соответствует название рыбы в fishes1(['Судак','Лещ','Окунь','Ёрш']) число обозначает шт рыбы, оставшиеся окуни)
kolvofishes(P,Points,Okynb,Out,OutOk) :- !, p(Points,X), slag(X, Okynb, WSp, P, Out, OutOk).
%проверяем список слагаемых (двойной список слагаемых, кол во окуней, вспомогательный список, Кол-во рыб у панина, конечный список, конечное кол-во окуней)
slag([H|Tail], Okynb, WSp, P, Out,OutOk) :- length(H, Len), P > Len, slag1(H, Okynb, Out1, Oku),!,slag(Tail, Oku, Out1, P, Out,OutOk). % отрицание 
slag([H|Tail], Okynb, WSp, P, Out, OutOk) :- slag(Tail, Okynb, WSp, P, Out,OutOk).
slag([], Okynb, WSp, P, WSp, Okynb).
%(список слагаемых, кол во окуней, конечный список слагаемых, осталось окуней)
slag1([], O, [0, 0, 0, 0], O).
slag1([1|Tail1], Okynb, [M5, M4, M2, M1], Oku) :- slag1(Tail1, Okynb, [M5, M4, M2, M11], Oku), M1 is M11 + 1.
slag1([2|Tail1], Okynb, [M5, M4, M2, M1], Oku) :- Okynb > 0, Okynb1 is Okynb - 1, slag1(Tail1, Okynb1, [M5, M4, M22, M1], Oku),M2 is M22 + 1.
slag1([4|Tail1], Okynb, [M5, M4, M2, M1], Oku) :- slag1(Tail1, Okynb, [M5, M44, M2, M1], Oku),M4 is M44 + 1.
slag1([5|Tail1], Okynb, [M5, M4, M2, M1], Oku) :- slag1(Tail1, Okynb, [M55, M4, M2, M1], Oku), M5 is M55 + 1.
%(список рыб типа [0,1,0,1], вспомогательный список, конечный список, кол-во окуней) из списка где отмеченно сколько какой рыбы поймал рыбак получаем список из названий рыбы
listfishesout(SpR,Oku,Out) :- ifok(SpR,Oku,Out1),!,listfishes(Out1, [], Out).
listfishesout(SpR,Oku,Out) :- listfishes(SpR, WList, Out).

ifok([0,0,2,0],Oku,[0,0,2,0]) :- !.
ifok([0,1,0,0],Oku,Out) :- Oku =:= 2, !, ifok([0,0,2,0],Oku,Out).

listfishes([], Out, Out) :- !.
listfishes([H|T], WList, OutList) :- H > 0, length([H|T], N), fishes1(ListNF), nameF(H, ListNF, N, WL, Out1), add(Out1,WList,Out),
 listfishes(T, Out, OutList),!.
listfishes([H|T], WList, OutList) :- listfishes(T, WList, OutList).
% ( кол во рыбы одного вида, список из названий рыб,длинна списка, вспомогательный список, вывод)
nameF(0, [HNF|TNF], 0, WL, WL) :- !.
nameF(H, [HNF|TNF], N, [], Out) :- length([HNF|TNF],NNF), NNF > N, !, nameF(H, TNF, N, [], Out).
nameF(H, [HNF|TNF], N, WL, Out) :- H > 0, H1 is H - 1, add(HNF, WL, Out1), !,nameF(H1, [HNF], 0, Out1, Out).

% рыбы панина(панин, вспомогательный список, конечный список)
fishesPanin(0,Sp,Sp).
fishesPanin(P,Sp,Out) :- P > 0, P1 is P - 1, fishes([Sud, Lesh, Ok, [Ersh,_]]), add(Ersh,Sp,Out1), fishesPanin(P1,Out1,Out),!.
% формируем подходящий список баллов (очков у сергея, конечный список)
serchpointsout(S,OutSp) :- serchpoints1(S, Sp, Out),serchpoints(1, Out, OutSp).
% распределяем очки между Борисовым и Паниным (вспомогательный параметр ,вспомогательный список, конечный список)
serchpoints(0, [B,P,S,L], [B,P,S,L]).
serchpoints(1, [B,P,S,L], Out) :- check([B,P,S,L]),!,
 serchpoints(0, [B,P,S,L], Out).
serchpoints(1, [B,P,S,L], Out) :- P > 0, B1 is B + 1, P1 is P - 1, serchpoints(1, [B1,P1,S,L], Out).
% распределяем очки между парами (вспомогательный параметр ,вспомогательный список, конечный список)
serchpoints1(0, [S,4,S,4], [S,4,S,4]) :- !.
serchpoints1(S, [OB1,OP1,OS1,OL1], Out) :- serchpoints1(0, [S,4,S,4], Out).

main(S1, BO,PO,SO,LO) :- serchpointsout(S1,[B,P,S,L]),kolvofishes(P,B,3,OutB,OstOkun),kolvofishes(P,S,OstOkun,OutSer,OstOkun1),
 kolvofishes(P,L,OstOkun1,OutL,OstOkun2), listfishesout(OutB, OstOkun2, BO), listfishesout(OutSer, OstOkun2, SO), 
 listfishesout(OutL, OstOkun, LO), fishesPanin(P,[],PO).% main([B1,P1,S1,L1], [BO,PO,SO,LO]).

mainmain(BO,PO,SO,LO) :- main(5, BO,PO,SO,LO).
```
#### Результат работы.
```prolog
?- mainmain(Borisov,Panin,Sergeev,Lednev).
Borisov = [['Лещ'], ['Окунь']],
Panin = ['Ёрш', 'Ёрш', 'Ёрш'],
Sergeev = [['Судак']],
Lednev = [['Окунь', 'Окунь']].

?- solve(Borisov,Panin,Sergeev,Lednev).
Borisov = [['Лещ'], ['Окунь']],
Panin = ['Ёрш', 'Ёрш', 'Ёрш'],
Sergeev = [['Судак']],
Lednev = [['Окунь', 'Окунь']].

```

## Выводы

Результатом работы моей программы является единственно верное непротиворечивое решение. Все условия задачи соблюдены. Моя программа эффективна, потому что я отсекаю "холостые" проходы циклов, также все немногочисленные переборы оптимизированные. Сложность при решении перебором О(!n), при подсчете баллов О(n). Также программа безопасна, так как я проверял чтобы все отсечения были "зелеными".

Пролог, безусловно, удобен для решения подобных задач, пока в них не встречается большое количество чисел которые нужно считать, к счастью в этой задаче такого не много. Описав ряд условий, мы отсекаем неподходящие варианты и находим нужное решение. Это намного проще, чем решать вручную, если бы мы, подобно программе, проверяли все возможные решения. Насколько эффективнее написание программы по сравнению с "ручным" решением вопрос спорный. Если такая задача одна и там немного входных данных, то проще решить ее на бумаге.